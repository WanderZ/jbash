/* Generated By:JavaCC: Do not edit this line. jBash.java */
package jBash;
import java.text.SimpleDateFormat;
import java.util.*;
import java.io.*;
import SPTP.protocol.CommonClasses.Compression;
import SPTP.protocol.CommonClasses.Compression.compressionType;

import SPTP.protocol.ClientInterface.SPTPclient;
import SPTP.protocol.ClientInterface.SPTPclientInterface;
import SPTP.protocol.ServerInterface.ServerInterface;
import SPTP.protocol.ServerInterface.ServerThread;
/**
 * <p>jBash Java Parser for the Bourne Again Shell:<ul>
 * </ol>
 * jBash is a parser that accepts a syntax similar to bash.
 * The idea is to create a pseudo-shell that can run on any kind of
 * devices, from a smartphone to normal pc.
 * </ul>
 */


public class jBash implements jBashConstants {
  private static jBash parser;
  private static int numVariables = 0;
  public final static String bashVersion = "jBash 0.2 By Emanuele Palumbo and Vincenzo Dentamaro";
  public final static String version = "0.2";
        /** List containing the name and value of environment variables bash */
public static List<jBashItem> list1;

  /** Used as temporary buffer for inclusion in the lists of environment variables*/
public static String temporanea1;
  public static String temporanea2;
  /** Working directory*/
public static String dir;

  public static void main(String args[]){
    temporanea1 = new String();
    temporanea2 = new String();
    /** Working directory, tilde = home directory */
dir = new String();
    dir = "~";
  list1 = new LinkedList<jBashItem>();
    /**The Parser works on standard input if not the past is no argument,
    otherwise working on a file when it is passed the filename as a parameter */
if (args.length == 0){
      System.out.println("jBash Parser Version "+version+":  Reading from standard input . . .");
      parser = new jBash(System.in);
    }
    else if (args.length == 1){
      System.out.println("jBash Parser Version "+version+":  Reading from file "+args[0]+" . . .");
      try {
        parser = new jBash(new java.io.FileInputStream(args[0]));
      }
      catch (java.io.FileNotFoundException e){
        System.out.println("jBash Parser Version "+version+":  File "+args[0]+" not found.");
        return ;
      }
    }
    else {
      System.out.println("jBash Parser Version "+version+":  Usage is one of:");
      System.out.println("         java jBash < inputfile");
      System.out.println("OR");
      System.out.println("         java jBash inputfile");
      return ;
    }
    Token t;
    /** The parser works until the exit command is executed. If the error is printed
     display the kind of mistake and its place in the spring. The parser continues to work
     if error: return to the seed of grammar*/
while (true){

System.out.print(System.getProperty("user.name")+"@jBash:"+dir+"#");
      try {
        parser.Input();
      }
      catch (ParseException e){
        System.out.println(e.getMessage());
        System.out.println("I try to continue from start.");
        parser.ReInit(token_source);
      //It synchronizes with the purpose of grammar
      }
    }
  }


  /**
	@method adds at the bottom of the linked list list1 objects created.
	@kind Dynamic scope with linked list.
	*/
public static void addItems(String name, String value){
   boolean found = false;
   jBashItem item = new jBashItem(name,value);
   ListIterator<jBashItem> iterator = list1.listIterator();
   while (iterator.hasNext() & !found){
   jBashItem temp = iterator.next();
   if(temp.toString().equals(name)){
       found = true;
       temp.setvalueField(value);
       temp.active = true;
      }
   }
   if(!found) list1.add(item);
}

  /**
@method Removes the object whose name the string value passed.

*/
public static void removeItems(String name){
  int toRemove = searchItems(name);
  if(toRemove != -1){
     list1.remove(toRemove);

  }else System.out.println("Unable to remove item. Item not found!");

}
  /**
	@method Search for the item in the past in list1 input and returns its position in the list.
    @return the position in the list.
	*/
private static int searchItems(String name){
  boolean found = false;
  int pos = -1 ;
  int i = 0;
  ListIterator<jBashItem> iterator = list1.listIterator();
  while (iterator.hasNext() & !found){
   jBashItem temp = iterator.next();
   if(temp.toString().equals(name)){
      pos =  i;
      found = true;
      }
   i++;
   }
 return pos;


}
  /**
	@method it tests of the existence of the directory given as parameter by the cd command, print screen
            the error message if the outcome of the test is negative, otherwise change the variable
            Which indicates the working directory*/
public static void dirExists(String directory){
    File file = new File(directory);
    boolean exists = file.exists();
    if (!exists){
      System.out.println("No such file or directory");
    }
    else {
      dir = directory;
    }
  }
  /**
  @method executes the command passed as a parameter, then returns an output value (0 or 1)
           indicating the success or failure of the enforcement.
   */
public static void executeCommand(String command){
    try {
      Process p = Runtime.getRuntime().exec(command);
      p.waitFor();
      System.out.println(p.exitValue());
    }
    catch (Exception err){
      System.out.println("Command not found!");
    }
  }


  public static void createServer(int port,Compression.compressionType type)
  {
   try {
                Runtime runtime = Runtime.getRuntime();
        int nrOfProcessors = runtime.availableProcessors();

                ServerInterface server = new ServerThread("jBash Secure Protocol",port,nrOfProcessors,type,null,"vincenzoServer");

    }
    catch (Exception err){
      System.out.println("Command not found!");
    }

  }

  public static void sendCommand(String ip,int port,String command)
 {
   try {

                Runtime runtime = Runtime.getRuntime();
        int nrOfProcessors = runtime.availableProcessors();
       SPTPclientInterface client = new SPTPclient(port, nrOfProcessors, "","vincenzo");
        boolean connected = client.connect(ip);
       client.sendCommand(command);
       client.closeConnection();
       System.exit(0);

      }
    catch (Exception err){
      System.out.println("Error sending command");
    }

  }


    public static void getFile(String ip,int port,String filename)
 {
   try {
                Runtime runtime = Runtime.getRuntime();
        int nrOfProcessors = runtime.availableProcessors();
         SPTPclientInterface client = new SPTPclient(port, nrOfProcessors, "","vincenzo");
      boolean connected = client.connect(ip);
        long start = System.currentTimeMillis();

        client.getFile(filename);
                                                        long elapsed = System.currentTimeMillis() - start;
                                                        System.out.println("Elapsed " +(elapsed/1000)+" seconds" );
                                                client.closeConnection();
         System.exit(0);

    }
    catch (Exception err){
      System.out.println("Command not found!");
    }

  }

    public static void putFile(String ip,int port,String filename)
 {
   try {
                Runtime runtime = Runtime.getRuntime();
        int nrOfProcessors = runtime.availableProcessors();

     SPTPclientInterface client = new SPTPclient(port, nrOfProcessors, "","vincenzo");
      boolean connected = client.connect(ip);
     client.putFile(filename);

         client.closeConnection();
      System.exit(0);

    }
    catch (Exception err){
      System.out.println("Command not found!");
    }

  }

    public static void changeDir(String ip,int port,String dir)
 {
   try {
                Runtime runtime = Runtime.getRuntime();
        int nrOfProcessors = runtime.availableProcessors();

       SPTPclientInterface client = new SPTPclient(port, nrOfProcessors, "","vincenzo");
        boolean connected = client.connect(ip);
        client.changeDirectory("/Users/macbook/Documents/workspace/SPTP/bin");
        client.retriveFileList();
         client.closeConnection();

    }
    catch (Exception err){
      System.out.println("Command not found!");
    }

  }

    public static void listDir(String ip,int port)
 {
   try {
                Runtime runtime = Runtime.getRuntime();
        int nrOfProcessors = runtime.availableProcessors();
       SPTPclientInterface client = new SPTPclient(port, nrOfProcessors, "","vincenzo");
       boolean connected = client.connect(ip);
       client.retriveFileList();
        client.closeConnection();

    }
    catch (Exception err){
      System.out.println("Command not found!");
    }

  }

         /**In case of error, this method shows a video message about the
     the error and about the expected token,then it will simulate an insertion of
     the expected token and continue to carry out the parsing by
     resynchronizing with grammar from the point where the parser was stopped.
   */
  static void onErrorSkipTO(int kind) throws ParseException {
  ParseException e = generateParseException();
  // generate the exception object.
System.out.println("\u005cn"+e.toString()+"\u005cn*** Was attended token "+jBashConstants.tokenImage[kind].toString()+" ***");
  // print the error message  
System.out.println("\u005cnI try to continue with parse -->\u005cn");
  Token t;
  do {
    t = new Token(kind);
  //   t = getNextToken();
}
  while (t.kind != kind);
  }

/** The purpose of grammar */
  static final public void Input() throws ParseException {
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CRLF:
        ;
        break;
      default:
        break label_1;
      }
      jj_consume_token(CRLF);
    }
    list();
    jj_consume_token(0);
  }

  static final public void list() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      jj_consume_token(LBRACE);
      in();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RBRACE:
        jj_consume_token(RBRACE);
        break;
      default:
        onErrorSkipTO(RBRACE);
      }
      break;
    case LTON:
      jj_consume_token(LTON);
      in();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RTON:
        jj_consume_token(RTON);
        break;
      default:
        onErrorSkipTO(RTON);
      }
      break;
    case 0:
    case EQUAL:
    case DIFFERENT:
    case ESCL:
    case DLTON:
    case IF:
    case FOR:
    case WHILE:
    case UNTIL:
    case SELECT:
    case CASE:
    case FUNCTION:
    case RETURN:
    case BASH_VERSION:
    case ALIAS:
    case BREAK:
    case CD:
    case COMMAND:
    case DECLARE:
    case ECHO:
    case EXEC:
    case EXIT:
    case EXPORT:
    case HELP:
    case KILL:
    case SPTP:
    case SUSPEND:
    case TEST:
    case TIMES:
    case ULIMIT:
    case UMASK:
    case UNALIAS:
    case UNSET:
    case WAIT:
    case NOME_VALIDO:
    case STRINGA:
    case DIRECTORY:
    case PARAM:
      unitaryList();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_2:
    while (true) {
      if (jj_2_1(2)) {
        ;
      } else {
        break label_2;
      }
      separator();
      list();
    }
  }

  static final public void in() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
    case DIFFERENT:
    case ESCL:
    case DLTON:
    case IF:
    case FOR:
    case WHILE:
    case UNTIL:
    case SELECT:
    case CASE:
    case FUNCTION:
    case RETURN:
    case BASH_VERSION:
    case ALIAS:
    case BREAK:
    case CD:
    case COMMAND:
    case DECLARE:
    case ECHO:
    case EXEC:
    case EXIT:
    case EXPORT:
    case HELP:
    case KILL:
    case SPTP:
    case SUSPEND:
    case TEST:
    case TIMES:
    case ULIMIT:
    case UMASK:
    case UNALIAS:
    case UNSET:
    case WAIT:
    case NOME_VALIDO:
    case STRINGA:
    case DIRECTORY:
    case PARAM:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BASH_VERSION:
      case ALIAS:
      case BREAK:
      case CD:
      case COMMAND:
      case DECLARE:
      case ECHO:
      case EXEC:
      case EXIT:
      case EXPORT:
      case HELP:
      case KILL:
      case SPTP:
      case SUSPEND:
      case TEST:
      case TIMES:
      case ULIMIT:
      case UMASK:
      case UNALIAS:
      case UNSET:
      case WAIT:
        built_in_commands();
        break;
      case EQUAL:
      case DIFFERENT:
      case ESCL:
      case DLTON:
      case STRINGA:
      case DIRECTORY:
      case PARAM:
        expression();
        break;
      case IF:
      case FOR:
      case WHILE:
      case UNTIL:
      case SELECT:
      case CASE:
      case FUNCTION:
      case RETURN:
      case NOME_VALIDO:
        control_block();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_3:
      while (true) {
        if (jj_2_2(2)) {
          ;
        } else {
          break label_3;
        }
        separator();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BASH_VERSION:
        case ALIAS:
        case BREAK:
        case CD:
        case COMMAND:
        case DECLARE:
        case ECHO:
        case EXEC:
        case EXIT:
        case EXPORT:
        case HELP:
        case KILL:
        case SPTP:
        case SUSPEND:
        case TEST:
        case TIMES:
        case ULIMIT:
        case UMASK:
        case UNALIAS:
        case UNSET:
        case WAIT:
          built_in_commands();
          break;
        case EQUAL:
        case DIFFERENT:
        case ESCL:
        case DLTON:
        case STRINGA:
        case DIRECTORY:
        case PARAM:
          expression();
          break;
        case IF:
        case FOR:
        case WHILE:
        case UNTIL:
        case SELECT:
        case CASE:
        case FUNCTION:
        case RETURN:
        case NOME_VALIDO:
          control_block();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
        break;
      default:
        onErrorSkipTO(SEMICOLON);
      }
      break;
    case 0:
      jj_consume_token(0);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void unitaryList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BASH_VERSION:
    case ALIAS:
    case BREAK:
    case CD:
    case COMMAND:
    case DECLARE:
    case ECHO:
    case EXEC:
    case EXIT:
    case EXPORT:
    case HELP:
    case KILL:
    case SPTP:
    case SUSPEND:
    case TEST:
    case TIMES:
    case ULIMIT:
    case UMASK:
    case UNALIAS:
    case UNSET:
    case WAIT:
      built_in_commands();
      break;
    case EQUAL:
    case DIFFERENT:
    case ESCL:
    case DLTON:
    case STRINGA:
    case DIRECTORY:
    case PARAM:
      expression();
      break;
    case IF:
    case FOR:
    case WHILE:
    case UNTIL:
    case SELECT:
    case CASE:
    case FUNCTION:
    case RETURN:
    case NOME_VALIDO:
      control_block();
      break;
    case 0:
      jj_consume_token(0);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void control_block() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      if_statement();
      break;
    case FOR:
      for_statement();
      break;
    case WHILE:
      while_statement();
      break;
    case UNTIL:
      until_statement();
      break;
    case RETURN:
      return_stm();
      break;
    case FUNCTION:
    case NOME_VALIDO:
      function();
      break;
    case SELECT:
      select_statement();
      break;
    case CASE:
      case_statement();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void separator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PIPE:
      jj_consume_token(PIPE);
      break;
    case AND:
      jj_consume_token(AND);
      break;
    case DOUBLEPIPE:
      jj_consume_token(DOUBLEPIPE);
      break;
    case DOUBLEAND:
      jj_consume_token(DOUBLEAND);
      break;
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    case CRLF:
      label_4:
      while (true) {
        jj_consume_token(CRLF);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CRLF:
          ;
          break;
        default:
          break label_4;
        }
      }
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void expr_concat() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOUBLEPIPE:
      jj_consume_token(DOUBLEPIPE);
      break;
    case DOUBLEAND:
      jj_consume_token(DOUBLEAND);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void test_param() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ESCL:
      jj_consume_token(ESCL);
      break;
    case PARAM:
      jj_consume_token(PARAM);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void op_conf() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOUBLEEQUAL:
      jj_consume_token(DOUBLEEQUAL);
      break;
    case DIFFERENT:
      jj_consume_token(DIFFERENT);
      break;
    case MINOR:
      jj_consume_token(MINOR);
      break;
    case MAJOR:
      jj_consume_token(MAJOR);
      break;
    case MINEQ:
      jj_consume_token(MINEQ);
      break;
    case MAJEQ:
      jj_consume_token(MAJEQ);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void redirection_op() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MINOR:
      jj_consume_token(MINOR);
      break;
    case DOUBLEMIN:
      jj_consume_token(DOUBLEMIN);
      break;
    case MAJOR:
      jj_consume_token(MAJOR);
      break;
    case DOUBLEMAJ:
      jj_consume_token(DOUBLEMAJ);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void operatore_alta_priorita() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRODUCT:
      jj_consume_token(PRODUCT);
      break;
    case DIVISION:
      jj_consume_token(DIVISION);
      break;
    case MODULE:
      jj_consume_token(MODULE);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void expression() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DLTON:
      arithmetic_eval();
      break;
    case EQUAL:
    case DIFFERENT:
    case ESCL:
    case STRINGA:
    case DIRECTORY:
    case PARAM:
      conditional_expr();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//////////////////////////////
  static final public void conditional_expr() throws ParseException {
    if (jj_2_3(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRINGA:
        jj_consume_token(STRINGA);
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ESCL:
      case PARAM:
        test_param();
        break;
      case DIFFERENT:
        jj_consume_token(DIFFERENT);
        break;
      case EQUAL:
        jj_consume_token(EQUAL);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(STRINGA);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ESCL:
      case DIRECTORY:
      case PARAM:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIRECTORY:
          jj_consume_token(DIRECTORY);
          break;
        default:
          ;
        }
        test_param();
        jj_consume_token(DIRECTORY);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  static final public void arithmetic_eval() throws ParseException {
    jj_consume_token(DLTON);
    formula();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOUBLEAND:
    case DOUBLEPIPE:
      sub();
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DRTON:
      jj_consume_token(DRTON);
      break;
    default:
      onErrorSkipTO(DRTON);
    }
  }

  static final public void sub() throws ParseException {
    expr_concat();
    formula();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOUBLEAND:
    case DOUBLEPIPE:
      sub();
      break;
    default:
      ;
    }
  }

  static final public void formula() throws ParseException {
    alg();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOUBLEEQUAL:
    case DIFFERENT:
    case MINOR:
    case MAJOR:
    case MINEQ:
    case MAJEQ:
      op_conf();
      alg();
      break;
    default:
      ;
    }
  }

  static final public void alg() throws ParseException {
    terminale_alta_priorita();
    if (jj_2_4(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        jj_consume_token(PLUS);
        break;
      case MIN:
        jj_consume_token(MIN);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      terminale_alta_priorita();
    } else {
      ;
    }
  }

  static final public void terminale_alta_priorita() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MIN:
      jj_consume_token(MIN);
      alg();
      break;
    case LTON:
      jj_consume_token(LTON);
      alg();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RTON:
        jj_consume_token(RTON);
        break;
      default:
        onErrorSkipTO(RTON);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRODUCT:
      case DIVISION:
      case MODULE:
        operatore_alta_priorita();
        alg();
        break;
      default:
        ;
      }
      break;
    default:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMERO:
        jj_consume_token(NUMERO);
        break;
      default:
        onErrorSkipTO(NUMERO);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRODUCT:
      case DIVISION:
      case MODULE:
        operatore_alta_priorita();
        alg();
        break;
      default:
        ;
      }
    }
  }

  static final public void select_statement() throws ParseException {
    jj_consume_token(SELECT);
    jj_consume_token(NOME_VALIDO);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IN:
      jj_consume_token(IN);
      label_5:
      while (true) {
        jj_consume_token(NOME_VALIDO);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NOME_VALIDO:
          ;
          break;
        default:
          break label_5;
        }
      }
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      onErrorSkipTO(SEMICOLON);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DO:
      jj_consume_token(DO);
      break;
    default:
      onErrorSkipTO(DO);
    }
    list();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      onErrorSkipTO(SEMICOLON);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DONE:
      jj_consume_token(DONE);
      break;
    default:
      onErrorSkipTO(DONE);
    }
  }

  static final public void case_statement() throws ParseException {
    jj_consume_token(CASE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BILL:
      jj_consume_token(BILL);
      jj_consume_token(NOME_VALIDO);
      break;
    case NOME_VALIDO:
      jj_consume_token(NOME_VALIDO);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IN:
      jj_consume_token(IN);
      break;
    default:
      onErrorSkipTO(IN);
    }
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LTON:
      case NOME_VALIDO:
        ;
        break;
      default:
        break label_6;
      }
      case_block();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ESAC:
      jj_consume_token(ESAC);
      break;
    default:
      onErrorSkipTO(ESAC);
    }
  }

  static final public void case_block() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LTON:
      jj_consume_token(LTON);
      break;
    default:
      ;
    }
    jj_consume_token(NOME_VALIDO);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PIPE:
      case_tail();
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RTON:
      jj_consume_token(RTON);
      break;
    default:
      onErrorSkipTO(RTON);
    }
    list();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOUBLESEMICOLON:
      jj_consume_token(DOUBLESEMICOLON);
      break;
    default:
      onErrorSkipTO(DOUBLESEMICOLON);
    }
  }

  static final public void case_tail() throws ParseException {
    jj_consume_token(PIPE);
    jj_consume_token(NOME_VALIDO);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PIPE:
      case_tail();
      break;
    default:
      ;
    }
  }

  static final public void if_statement() throws ParseException {
    jj_consume_token(IF);
    list();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THEN:
      jj_consume_token(THEN);
      break;
    default:
      onErrorSkipTO(THEN);
    }
    list();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELIF:
      elif_substatement();
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      list();
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FI:
      jj_consume_token(FI);
      break;
    default:
      onErrorSkipTO(FI);
    }
  }

  static final public void elif_substatement() throws ParseException {
    jj_consume_token(ELIF);
    list();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THEN:
      jj_consume_token(THEN);
      break;
    default:
      onErrorSkipTO(THEN);
    }
    list();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELIF:
      elif_substatement();
      break;
    default:
      ;
    }
  }

/**Under the for between one and another <SEMICOLON> we need a space,
otherwise returns error */
  static final public void for_statement() throws ParseException {
    jj_consume_token(FOR);
    jj_consume_token(DLTON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
    case DIFFERENT:
    case ESCL:
    case DLTON:
    case STRINGA:
    case DIRECTORY:
    case PARAM:
      expression();
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      onErrorSkipTO(SEMICOLON);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
    case DIFFERENT:
    case ESCL:
    case DLTON:
    case STRINGA:
    case DIRECTORY:
    case PARAM:
      expression();
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      onErrorSkipTO(SEMICOLON);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
    case DIFFERENT:
    case ESCL:
    case DLTON:
    case STRINGA:
    case DIRECTORY:
    case PARAM:
      expression();
      break;
    default:
      ;
    }
    jj_consume_token(DRTON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DO:
      jj_consume_token(DO);
      break;
    default:
      onErrorSkipTO(DO);
    }
    list();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DONE:
      jj_consume_token(DONE);
      break;
    default:
      onErrorSkipTO(DONE);
    }
  }

  static final public void while_statement() throws ParseException {
    jj_consume_token(WHILE);
    list();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DO:
      jj_consume_token(DO);
      break;
    default:
      onErrorSkipTO(DO);
    }
    list();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DONE:
      jj_consume_token(DONE);
      break;
    default:
      onErrorSkipTO(DONE);
    }
  }

  static final public void until_statement() throws ParseException {
    jj_consume_token(UNTIL);
    list();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DO:
      jj_consume_token(DO);
      break;
    default:
      onErrorSkipTO(DO);
    }
    list();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DONE:
      jj_consume_token(DONE);
      break;
    default:
      onErrorSkipTO(DONE);
    }
  }

  static final public void statement_di_assegnamento() throws ParseException {
  Token t1, t2;
    t1 = jj_consume_token(NOME_VALIDO);
    t2 = jj_consume_token(EQUAL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BILL:
    case DLTON:
    case NOME_VALIDO:
    case STRINGA:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOME_VALIDO:
        jj_consume_token(NOME_VALIDO);
        break;
      case DLTON:
        arithmetic_eval();
        break;
      case STRINGA:
        t2 = jj_consume_token(STRINGA);
        break;
      default:
        if (jj_2_5(2)) {
          jj_consume_token(BILL);
          t2 = jj_consume_token(NOME_VALIDO);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      ;
    }
    temporanea1 = t1.toString();
    temporanea2 = t2.toString();
  }

  static final public void function() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FUNCTION:
      jj_consume_token(FUNCTION);
      break;
    default:
      ;
    }
    jj_consume_token(NOME_VALIDO);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LTON:
      jj_consume_token(LTON);
      break;
    default:
      onErrorSkipTO(LTON);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RTON:
      jj_consume_token(RTON);
      break;
    default:
      onErrorSkipTO(RTON);
    }
    list();
    if (jj_2_6(2)) {
      redirection();
    } else {
      ;
    }
  }

  static final public void redirection() throws ParseException {
    redirection_op();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIRECTORY:
      jj_consume_token(DIRECTORY);
      break;
    default:
      onErrorSkipTO(DIRECTORY);
    }
  }

  static final public void return_stm() throws ParseException {
    jj_consume_token(RETURN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMERO:
    case ZERO:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMERO:
        jj_consume_token(NUMERO);
        break;
      case ZERO:
        jj_consume_token(ZERO);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      ;
    }
  }

//BUILT-IN COMMANDS
  static final public void built_in_commands() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BASH_VERSION:
      bash_version();
      break;
    case ALIAS:
      alias_stm();
      break;
    case BREAK:
      break_stm();
      break;
    case CD:
      changedir_stm();
      break;
    case COMMAND:
      command();
      break;
    case DECLARE:
      declare_stm();
      break;
    case ECHO:
      echo_stm();
      break;
    case EXEC:
      exec_stm();
      break;
    case EXIT:
      exit_stm();
      break;
    case EXPORT:
      export_stm();
      break;
    case HELP:
      help_stm();
      break;
    case KILL:
      kill_stm();
      break;
    case SUSPEND:
      suspend_stm();
      break;
    case TEST:
      test_expr_stm();
      break;
    case TIMES:
      times_stm();
      break;
    case ULIMIT:
      ulimit_stm();
      break;
    case UMASK:
      umask_stm();
      break;
    case UNALIAS:
      unalias_stm();
      break;
    case UNSET:
      unset_stm();
      break;
    case WAIT:
      wait_stm();
      break;
    case SPTP:
      sptp_stm();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void bash_version() throws ParseException {
    jj_consume_token(BASH_VERSION);
    System.out.println(bashVersion);
  }

  static final public void alias_stm() throws ParseException {
    jj_consume_token(ALIAS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PARAM:
      jj_consume_token(PARAM);
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOME_VALIDO:
      statement_di_assegnamento();
      break;
    default:
      ;
    }
    addItems(temporanea1,temporanea2);
  }

  static final public void break_stm() throws ParseException {
    jj_consume_token(BREAK);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMERO:
    case ZERO:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMERO:
        jj_consume_token(NUMERO);
        break;
      case ZERO:
        jj_consume_token(ZERO);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      ;
    }
  }

  static final public void changedir_stm() throws ParseException {
  Token t;
    t = jj_consume_token(CD);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PARAM:
      jj_consume_token(PARAM);
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIRECTORY:
      t = jj_consume_token(DIRECTORY);
      break;
    default:
      ;
    }
    dirExists(t.toString());
  }

/** Command executes the command it has built-in or external, and Unlike exec
     does not close the shell after its execution */
  static final public void command() throws ParseException {
  Token t;
    t = jj_consume_token(COMMAND);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PARAM:
        ;
        break;
      default:
        break label_7;
      }
      jj_consume_token(PARAM);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BASH_VERSION:
    case ALIAS:
    case BREAK:
    case CD:
    case COMMAND:
    case DECLARE:
    case ECHO:
    case EXEC:
    case EXIT:
    case EXPORT:
    case HELP:
    case KILL:
    case SPTP:
    case SUSPEND:
    case TEST:
    case TIMES:
    case ULIMIT:
    case UMASK:
    case UNALIAS:
    case UNSET:
    case WAIT:
    case NOME_VALIDO:
    case DIRECTORY:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BASH_VERSION:
      case ALIAS:
      case BREAK:
      case CD:
      case COMMAND:
      case DECLARE:
      case ECHO:
      case EXEC:
      case EXIT:
      case EXPORT:
      case HELP:
      case KILL:
      case SPTP:
      case SUSPEND:
      case TEST:
      case TIMES:
      case ULIMIT:
      case UMASK:
      case UNALIAS:
      case UNSET:
      case WAIT:
        built_in_commands();
        break;
      case NOME_VALIDO:
        t = jj_consume_token(NOME_VALIDO);
        break;
      case DIRECTORY:
        t = jj_consume_token(DIRECTORY);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      ;
    }
    if (!(t.toString().equals("command"))){
      executeCommand(t.toString());
    }
  }

  static final public void declare_stm() throws ParseException {
    jj_consume_token(DECLARE);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PARAM:
        ;
        break;
      default:
        break label_8;
      }
      jj_consume_token(PARAM);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOME_VALIDO:
      statement_di_assegnamento();
      break;
    default:
      ;
    }
  }

  static final public void echo_stm() throws ParseException {
  Token t;
    t = jj_consume_token(ECHO);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PARAM:
        ;
        break;
      default:
        break label_9;
      }
      jj_consume_token(PARAM);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BILL:
    case STRINGA:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRINGA:
        t = jj_consume_token(STRINGA);
        break;
      case BILL:
        jj_consume_token(BILL);
        t = jj_consume_token(NOME_VALIDO);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      ;
    }
    String token = t.toString();
    if (!token.substring(0, 1).equals("'")){
        for(jBashItem item : list1){
          if (item.toString().equals(token)) {
             if(item.active){
                System.out.println(item.getValueField());
               } else System.out.println("");

          }

      }
    } else System.out.println(token.substring(1, t.toString().length()-1));
  }

/** The exec command executes a command built-in or external, and at the end of his execution exits. */
  static final public void exec_stm() throws ParseException {
  Token t;
    t = jj_consume_token(EXEC);
    if (jj_2_7(2)) {
      jj_consume_token(PARAM);
    } else {
      ;
    }
    if (jj_2_8(2)) {
      jj_consume_token(PARAM);
      jj_consume_token(NOME_VALIDO);
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BASH_VERSION:
    case ALIAS:
    case BREAK:
    case CD:
    case COMMAND:
    case DECLARE:
    case ECHO:
    case EXEC:
    case EXIT:
    case EXPORT:
    case HELP:
    case KILL:
    case SPTP:
    case SUSPEND:
    case TEST:
    case TIMES:
    case ULIMIT:
    case UMASK:
    case UNALIAS:
    case UNSET:
    case WAIT:
    case NOME_VALIDO:
    case DIRECTORY:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BASH_VERSION:
      case ALIAS:
      case BREAK:
      case CD:
      case COMMAND:
      case DECLARE:
      case ECHO:
      case EXEC:
      case EXIT:
      case EXPORT:
      case HELP:
      case KILL:
      case SPTP:
      case SUSPEND:
      case TEST:
      case TIMES:
      case ULIMIT:
      case UMASK:
      case UNALIAS:
      case UNSET:
      case WAIT:
        built_in_commands();
        break;
      case NOME_VALIDO:
        t = jj_consume_token(NOME_VALIDO);
        break;
      case DIRECTORY:
        t = jj_consume_token(DIRECTORY);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      ;
    }
    if (!(t.toString().equals("exec"))){
      executeCommand(t.toString());
      System.out.println("I say goodbye!");
      Runtime.getRuntime().exit(0);
    }
  }

  static final public void exit_stm() throws ParseException {
    jj_consume_token(EXIT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMERO:
    case ZERO:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMERO:
        jj_consume_token(NUMERO);
        break;
      case ZERO:
        jj_consume_token(ZERO);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      ;
    }
        Random generatore = new Random();
        int casual = generatore.nextInt(3);
    if (casual == 0) System.out.println("Have a nice day "+
                                         System.getProperty("user.name")+"!");
    if (casual == 1) System.out.println("See you soon!");
    if (casual == 2) System.out.println("Have fun Mr."+
                                         System.getProperty("user.name")+"!");
    Runtime.getRuntime().exit(0);
  }

  static final public void export_stm() throws ParseException {
  Token t1;
  Token t2;
    t2 = jj_consume_token(EXPORT);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PARAM:
        ;
        break;
      default:
        break label_10;
      }
      jj_consume_token(PARAM);
    }
    t1 = jj_consume_token(NOME_VALIDO);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
      jj_consume_token(EQUAL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRINGA:
        t2 = jj_consume_token(STRINGA);
        break;
      case DIRECTORY:
        t2 = jj_consume_token(DIRECTORY);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      ;
    }
    String tempo = "";
    if (t1.toString().compareToIgnoreCase("")>0){
     String temporanea = t1.toString();

     if(!t2.toString().substring(0, 1).equals("'")){
       tempo = t2.toString();
     } else tempo = t2.toString().substring(1, t2.toString().length()-1);
      addItems(temporanea,tempo);
    }
  }

  static final public void help_stm() throws ParseException {
    jj_consume_token(HELP);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PARAM:
      jj_consume_token(PARAM);
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BASH_VERSION:
    case ALIAS:
    case BREAK:
    case CD:
    case COMMAND:
    case DECLARE:
    case ECHO:
    case EXEC:
    case EXIT:
    case EXPORT:
    case HELP:
    case KILL:
    case SPTP:
    case SUSPEND:
    case TEST:
    case TIMES:
    case ULIMIT:
    case UMASK:
    case UNALIAS:
    case UNSET:
    case WAIT:
    case NOME_VALIDO:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BASH_VERSION:
      case ALIAS:
      case BREAK:
      case CD:
      case COMMAND:
      case DECLARE:
      case ECHO:
      case EXEC:
      case EXIT:
      case EXPORT:
      case HELP:
      case KILL:
      case SPTP:
      case SUSPEND:
      case TEST:
      case TIMES:
      case ULIMIT:
      case UMASK:
      case UNALIAS:
      case UNSET:
      case WAIT:
        built_in_commands();
        break;
      case NOME_VALIDO:
        jj_consume_token(NOME_VALIDO);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      ;
    }
  }

  static final public void kill_stm() throws ParseException {
    jj_consume_token(KILL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PARAM:
      jj_consume_token(PARAM);
      jj_consume_token(NUMERO);
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMERO:
    case ZERO:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMERO:
        jj_consume_token(NUMERO);
        break;
      case ZERO:
        jj_consume_token(ZERO);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      ;
    }
  }

  static final public void suspend_stm() throws ParseException {
    jj_consume_token(SUSPEND);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PARAM:
      jj_consume_token(PARAM);
      break;
    default:
      ;
    }
  }

  static final public void test_expr_stm() throws ParseException {
    jj_consume_token(TEST);
    expression();
  }

  static final public void times_stm() throws ParseException {
    jj_consume_token(TIMES);
    Calendar cal = Calendar.getInstance();
    cal.getTime();
    SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss");
    System.out.println(sdf.format(cal.getTime()));
  }

  static final public void ulimit_stm() throws ParseException {
    jj_consume_token(ULIMIT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PARAM:
      jj_consume_token(PARAM);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMERO:
      case ZERO:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NUMERO:
          jj_consume_token(NUMERO);
          break;
        case ZERO:
          jj_consume_token(ZERO);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        ;
      }
      break;
    default:
      ;
    }
  }

  static final public void umask_stm() throws ParseException {
    jj_consume_token(UMASK);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PARAM:
      jj_consume_token(PARAM);
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMERO:
    case ZERO:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMERO:
        jj_consume_token(NUMERO);
        break;
      case ZERO:
        jj_consume_token(ZERO);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      ;
    }
  }

  static final public void unalias_stm() throws ParseException {
                    Token t;
    t = jj_consume_token(UNALIAS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PARAM:
      jj_consume_token(PARAM);
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOME_VALIDO:
      t = jj_consume_token(NOME_VALIDO);
      break;
    default:
      ;
    }
        if (!t.toString().equals("unalias")) removeItems(t.toString());
  }

  static final public void unset_stm() throws ParseException {
                  Token t;
    t = jj_consume_token(UNSET);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PARAM:
      jj_consume_token(PARAM);
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOME_VALIDO:
      t = jj_consume_token(NOME_VALIDO);
      break;
    default:
      ;
    }
        if (!t.toString().equals("unset")) removeItems(t.toString());
  }

  static final public void wait_stm() throws ParseException {
    jj_consume_token(WAIT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMERO:
    case ZERO:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMERO:
        jj_consume_token(NUMERO);
        break;
      case ZERO:
        jj_consume_token(ZERO);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      ;
    }
  }

  static final public void sptp_stm() throws ParseException {
  Token h = null;
  Token t2 = null;
  Token t3 = null;
  Token t4 = null;
    jj_consume_token(SPTP);
    if (jj_2_9(2)) {
      h = jj_consume_token(PARAM);
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMERO:
      t2 = jj_consume_token(NUMERO);
      break;
    default:
      ;
    }
    if (jj_2_10(4)) {
      t3 = jj_consume_token(STRINGA);
    } else {
      ;
    }
    if (jj_2_11(4)) {
      t4 = jj_consume_token(STRINGA);
    } else {
      ;
    }
                String t = "";
                if(h != null)
                {
                         t = h.toString();
                        }
    if(t.toString().equals("-s"))
    {
    createServer(Integer.parseInt(t2.toString()),Compression.compressionType.LZMA);
    }else
if(t.toString().equals("-c"))
    {
                String ip = t3.toString().substring(1,t3.toString().length()-1);
                String command = t4.toString().substring(1,t4.toString().length()-1);

     if (command.substring(0,4).equals("-get"))
     {
      getFile(ip, Integer.parseInt(t2.toString()), command.substring(5,command.length()));

     }
     if (command.substring(0,4).equals("-put"))
     {
      putFile(ip, Integer.parseInt(t2.toString()), command.substring(5,command.length()));

     }
     if (command.substring(0,4).equals("-chd"))
     {
      changeDir(ip, Integer.parseInt(t2.toString()), command.substring(5,command.length()));

     }

     if (command.substring(0,4).equals("-lst"))
     {
      listDir(ip, Integer.parseInt(t2.toString()));

     }

     if (command.substring(0,4).equals("-cmd"))
     {
      sendCommand(ip, Integer.parseInt(t2.toString()),command.substring(5,command.length()));

     }


    }else
    {
     System.out.println("SCURE PARALLEL TRANSFER PROTOCOL FOR JBASH\u005cn USAGE\u005cn"+
       "For server side: sptp -s port\u005cnFor client side: sptp -c port 'IP' 'command'");
       System.out.println("A valid command is:\u005cn-get filename\u005cn-put filename \u005cn-cmd command\u005cn"
       +"-lst\u005cn-chd direcotry");
       System.out.println("jBash and SPTP by Vincenzo Dentamaro (c) 2009-2010");

         }
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  static private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  static private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  static private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  static private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  static private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  static private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  static private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  static private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  static private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  static private boolean jj_3R_71() {
    if (jj_scan_token(CD)) return true;
    return false;
  }

  static private boolean jj_3R_62() {
    if (jj_3R_97()) return true;
    return false;
  }

  static private boolean jj_3R_61() {
    if (jj_3R_96()) return true;
    return false;
  }

  static private boolean jj_3_2() {
    if (jj_3R_11()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_13()) {
    jj_scanpos = xsp;
    if (jj_3R_14()) {
    jj_scanpos = xsp;
    if (jj_3R_15()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_60() {
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_59() {
    if (jj_3R_94()) return true;
    return false;
  }

  static private boolean jj_3R_58() {
    if (jj_3R_93()) return true;
    return false;
  }

  static private boolean jj_3R_57() {
    if (jj_3R_92()) return true;
    return false;
  }

  static private boolean jj_3R_70() {
    if (jj_scan_token(BREAK)) return true;
    return false;
  }

  static private boolean jj_3R_25() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) {
    jj_scanpos = xsp;
    if (jj_3R_59()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) {
    jj_scanpos = xsp;
    if (jj_3R_61()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_56() {
    if (jj_3R_91()) return true;
    return false;
  }

  static private boolean jj_3_1() {
    if (jj_3R_11()) return true;
    if (jj_3R_12()) return true;
    return false;
  }

  static private boolean jj_3R_67() {
    if (jj_3R_25()) return true;
    return false;
  }

  static private boolean jj_3R_66() {
    if (jj_3R_24()) return true;
    return false;
  }

  static private boolean jj_3R_69() {
    if (jj_scan_token(ALIAS)) return true;
    return false;
  }

  static private boolean jj_3R_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_65()) {
    jj_scanpos = xsp;
    if (jj_3R_66()) {
    jj_scanpos = xsp;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_65() {
    if (jj_3R_23()) return true;
    return false;
  }

  static private boolean jj_3R_15() {
    if (jj_3R_25()) return true;
    return false;
  }

  static private boolean jj_3R_14() {
    if (jj_3R_24()) return true;
    return false;
  }

  static private boolean jj_3R_68() {
    if (jj_scan_token(BASH_VERSION)) return true;
    return false;
  }

  static private boolean jj_3R_53() {
    if (jj_3R_88()) return true;
    return false;
  }

  static private boolean jj_3R_52() {
    if (jj_3R_87()) return true;
    return false;
  }

  static private boolean jj_3R_51() {
    if (jj_3R_86()) return true;
    return false;
  }

  static private boolean jj_3R_50() {
    if (jj_3R_85()) return true;
    return false;
  }

  static private boolean jj_3R_22() {
    if (jj_3R_32()) return true;
    return false;
  }

  static private boolean jj_3R_49() {
    if (jj_3R_84()) return true;
    return false;
  }

  static private boolean jj_3R_48() {
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3R_21() {
    if (jj_scan_token(LTON)) return true;
    return false;
  }

  static private boolean jj_3R_47() {
    if (jj_3R_82()) return true;
    return false;
  }

  static private boolean jj_3_6() {
    if (jj_3R_18()) return true;
    return false;
  }

  static private boolean jj_3R_46() {
    if (jj_3R_81()) return true;
    return false;
  }

  static private boolean jj_3R_45() {
    if (jj_3R_80()) return true;
    return false;
  }

  static private boolean jj_3R_20() {
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  static private boolean jj_3R_44() {
    if (jj_3R_79()) return true;
    return false;
  }

  static private boolean jj_3R_12() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_20()) {
    jj_scanpos = xsp;
    if (jj_3R_21()) {
    jj_scanpos = xsp;
    if (jj_3R_22()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_43() {
    if (jj_3R_78()) return true;
    return false;
  }

  static private boolean jj_3R_42() {
    if (jj_3R_77()) return true;
    return false;
  }

  static private boolean jj_3R_41() {
    if (jj_3R_76()) return true;
    return false;
  }

  static private boolean jj_3R_40() {
    if (jj_3R_75()) return true;
    return false;
  }

  static private boolean jj_3_9() {
    if (jj_scan_token(PARAM)) return true;
    return false;
  }

  static private boolean jj_3R_39() {
    if (jj_3R_74()) return true;
    return false;
  }

  static private boolean jj_3R_38() {
    if (jj_3R_73()) return true;
    return false;
  }

  static private boolean jj_3R_37() {
    if (jj_3R_72()) return true;
    return false;
  }

  static private boolean jj_3R_36() {
    if (jj_3R_71()) return true;
    return false;
  }

  static private boolean jj_3R_35() {
    if (jj_3R_70()) return true;
    return false;
  }

  static private boolean jj_3R_34() {
    if (jj_3R_69()) return true;
    return false;
  }

  static private boolean jj_3R_88() {
    if (jj_scan_token(SPTP)) return true;
    return false;
  }

  static private boolean jj_3R_33() {
    if (jj_3R_68()) return true;
    return false;
  }

  static private boolean jj_3R_23() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_33()) {
    jj_scanpos = xsp;
    if (jj_3R_34()) {
    jj_scanpos = xsp;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_3R_36()) {
    jj_scanpos = xsp;
    if (jj_3R_37()) {
    jj_scanpos = xsp;
    if (jj_3R_38()) {
    jj_scanpos = xsp;
    if (jj_3R_39()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) {
    jj_scanpos = xsp;
    if (jj_3R_41()) {
    jj_scanpos = xsp;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) {
    jj_scanpos = xsp;
    if (jj_3R_51()) {
    jj_scanpos = xsp;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_95() {
    if (jj_scan_token(RETURN)) return true;
    return false;
  }

  static private boolean jj_3R_31() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  static private boolean jj_3R_18() {
    if (jj_3R_30()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_3R_31()) return true;
    }
    return false;
  }

  static private boolean jj_3R_87() {
    if (jj_scan_token(WAIT)) return true;
    return false;
  }

  static private boolean jj_3R_96() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(51)) jj_scanpos = xsp;
    if (jj_scan_token(NOME_VALIDO)) return true;
    return false;
  }

  static private boolean jj_3R_86() {
    if (jj_scan_token(UNSET)) return true;
    return false;
  }

  static private boolean jj_3_5() {
    if (jj_scan_token(BILL)) return true;
    if (jj_scan_token(NOME_VALIDO)) return true;
    return false;
  }

  static private boolean jj_3R_85() {
    if (jj_scan_token(UNALIAS)) return true;
    return false;
  }

  static private boolean jj_3R_84() {
    if (jj_scan_token(UMASK)) return true;
    return false;
  }

  static private boolean jj_3R_94() {
    if (jj_scan_token(UNTIL)) return true;
    return false;
  }

  static private boolean jj_3R_83() {
    if (jj_scan_token(ULIMIT)) return true;
    return false;
  }

  static private boolean jj_3R_93() {
    if (jj_scan_token(WHILE)) return true;
    return false;
  }

  static private boolean jj_3R_82() {
    if (jj_scan_token(TIMES)) return true;
    return false;
  }

  static private boolean jj_3R_92() {
    if (jj_scan_token(FOR)) return true;
    return false;
  }

  static private boolean jj_3R_81() {
    if (jj_scan_token(TEST)) return true;
    return false;
  }

  static private boolean jj_3R_80() {
    if (jj_scan_token(SUSPEND)) return true;
    return false;
  }

  static private boolean jj_3R_79() {
    if (jj_scan_token(KILL)) return true;
    return false;
  }

  static private boolean jj_3R_91() {
    if (jj_scan_token(IF)) return true;
    return false;
  }

  static private boolean jj_3R_78() {
    if (jj_scan_token(HELP)) return true;
    return false;
  }

  static private boolean jj_3_4() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(26)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) return true;
    }
    if (jj_3R_17()) return true;
    return false;
  }

  static private boolean jj_3_8() {
    if (jj_scan_token(PARAM)) return true;
    if (jj_scan_token(NOME_VALIDO)) return true;
    return false;
  }

  static private boolean jj_3R_98() {
    if (jj_scan_token(CASE)) return true;
    return false;
  }

  static private boolean jj_3R_77() {
    if (jj_scan_token(EXPORT)) return true;
    return false;
  }

  static private boolean jj_3R_97() {
    if (jj_scan_token(SELECT)) return true;
    return false;
  }

  static private boolean jj_3R_64() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  static private boolean jj_3R_29() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(76)) {
    jj_scanpos = xsp;
    if (jj_3R_64()) return true;
    }
    return false;
  }

  static private boolean jj_3R_16() {
    if (jj_3R_26()) return true;
    return false;
  }

  static private boolean jj_3R_28() {
    if (jj_scan_token(LTON)) return true;
    return false;
  }

  static private boolean jj_3R_27() {
    if (jj_scan_token(MIN)) return true;
    return false;
  }

  static private boolean jj_3R_17() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_27()) {
    jj_scanpos = xsp;
    if (jj_3R_28()) {
    jj_scanpos = xsp;
    if (jj_3R_29()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_76() {
    if (jj_scan_token(EXIT)) return true;
    return false;
  }

  static private boolean jj_3_7() {
    if (jj_scan_token(PARAM)) return true;
    return false;
  }

  static private boolean jj_3R_89() {
    if (jj_scan_token(DLTON)) return true;
    return false;
  }

  static private boolean jj_3R_99() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(81)) jj_scanpos = xsp;
    if (jj_3R_26()) return true;
    return false;
  }

  static private boolean jj_3R_75() {
    if (jj_scan_token(EXEC)) return true;
    return false;
  }

  static private boolean jj_3_3() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(80)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_16()) {
    jj_scanpos = xsp;
    if (jj_scan_token(16)) {
    jj_scanpos = xsp;
    if (jj_scan_token(14)) return true;
    }
    }
    if (jj_scan_token(STRINGA)) return true;
    return false;
  }

  static private boolean jj_3R_90() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) return true;
    }
    return false;
  }

  static private boolean jj_3_11() {
    if (jj_scan_token(STRINGA)) return true;
    return false;
  }

  static private boolean jj_3R_55() {
    if (jj_3R_90()) return true;
    return false;
  }

  static private boolean jj_3R_54() {
    if (jj_3R_89()) return true;
    return false;
  }

  static private boolean jj_3R_24() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_54()) {
    jj_scanpos = xsp;
    if (jj_3R_55()) return true;
    }
    return false;
  }

  static private boolean jj_3R_30() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(17)) {
    jj_scanpos = xsp;
    if (jj_scan_token(21)) {
    jj_scanpos = xsp;
    if (jj_scan_token(18)) {
    jj_scanpos = xsp;
    if (jj_scan_token(22)) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_74() {
    if (jj_scan_token(ECHO)) return true;
    return false;
  }

  static private boolean jj_3R_13() {
    if (jj_3R_23()) return true;
    return false;
  }

  static private boolean jj_3R_73() {
    if (jj_scan_token(DECLARE)) return true;
    return false;
  }

  static private boolean jj_3R_26() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(29)) {
    jj_scanpos = xsp;
    if (jj_scan_token(83)) return true;
    }
    return false;
  }

  static private boolean jj_3R_72() {
    if (jj_scan_token(COMMAND)) return true;
    return false;
  }

  static private boolean jj_3_10() {
    if (jj_scan_token(STRINGA)) return true;
    return false;
  }

  static private boolean jj_3R_19() {
    Token xsp;
    if (jj_scan_token(9)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(9)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_11() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(10)) {
    jj_scanpos = xsp;
    if (jj_scan_token(11)) {
    jj_scanpos = xsp;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_scan_token(12)) {
    jj_scanpos = xsp;
    if (jj_scan_token(7)) {
    jj_scanpos = xsp;
    if (jj_3R_19()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_63() {
    if (jj_3R_98()) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public jBashTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;

  /** Constructor with InputStream. */
  public jBash(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public jBash(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new jBashTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }

  /** Constructor. */
  public jBash(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new jBashTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }

  /** Constructor with generated Token Manager. */
  public jBash(jBashTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
  }

  /** Reinitialise. */
  public void ReInit(jBashTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      return token;
    }
    token = oldToken;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    Token errortok = token.next;
    int line = errortok.beginLine, column = errortok.beginColumn;
    String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;
    return new ParseException("Parse error at line " + line + ", column " + column + ".  Encountered: " + mess);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
